@page "/"
@using BlazorMonaco
@using AngleSharp.Html.Parser
@using MonorailCss
@using System.Reactive.Subjects
@using System.Reactive.Linq
@inject IJSRuntime JS


<PageTitle>Index</PageTitle>

<div class="max-w-full inset-4 h-screen grid grid-cols-2 grid-rows-1">
    <div class="grid grid-cols-1 grid-rows-2">
        <div class="flex flex-col pb-2">
            <header class="flex-1 px-6 py-4 mb-2 bg-gray-800 text-gray-50 border-b border-gray-700">HTML</header>
            <MonacoEditor @ref="HtmlEditor" Id="htmlEditor" ConstructionOptions="EditorConstructionOptions" OnDidInit="EditorOnInit" OnDidChangeModelContent="_processHtml.OnNext"/>
        </div>
        <div class="flex flex-col border-t border-gray-700 pb-2">
            <header class="flex-1 px-6 py-4 mb-2 bg-gray-800 text-gray-50 border-b border-gray-700">Generated CSS</header>
            <MonacoEditor @ref="CssEditor" Id="cssViewer" ConstructionOptions="ViewerConstructionOptions" OnDidInit="EditorOnInit"/>
        </div>
    </div>
    <div>
        <div class="h-full w-full flex">
            <iframe @ref="PreviewViewer" class="flex-1 h-full w-full bg-white" sandbox="allow-popups-to-escape-sandbox allow-scripts allow-popups allow-forms allow-pointer-lock allow-top-navigation allow-modals" srcdoc="@HtmlContents"></iframe>
        </div>
    </div>
</div>

@code{
    private MonacoEditor HtmlEditor { get; set; } = null!;
    private MonacoEditor CssEditor { get; set; } = null!;
    private ElementReference PreviewViewer { get; set; }
    private string HtmlContents { get; set; } = string.Empty;

    private readonly CssFramework _frameworkWithNoReset = new CssFramework(DesignSystem.Default).WithCssReset(string.Empty);
    private readonly CssFramework _framework = new CssFramework(DesignSystem.Default).Apply("body", "font-sans");
    private readonly Subject<ModelContentChangedEvent> _processHtml = new();

    protected override void OnInitialized()
    {
        HtmlContents = PreviewHtml;

        _processHtml.Throttle(TimeSpan.FromMilliseconds(250))
            .SelectMany(_ => ModelChanged())
            .Subscribe(ts => { StateHasChanged(); });
    }

    private StandaloneEditorConstructionOptions StandardOptions() => new()
    {
        AutomaticLayout = true,
        Language = "html",
        GlyphMargin = true,
        HighlightActiveIndentGuide = false,
        Scrollbar = new EditorScrollbarOptions() { HorizontalScrollbarSize = 2, VerticalScrollbarSize = 8 },
        FoldingHighlight = false,
        RenderLineHighlightOnlyWhenFocus = true,
        RenderLineHighlight = "none",
        FontFamily = "'Cascadia Code', Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace",
        FontWeight = "300",
        FontSize = 14,
        Hover = new EditorHoverOptions()
        {
            Enabled = true,
            Delay = 100,
        },
        Minimap = new EditorMinimapOptions()
        {
            Enabled = false,
        },
        Folding = true,
        LineDecorationsWidth = "0",
        Contextmenu = false,
        Theme = "my-custom-theme"
    };

    private StandaloneEditorConstructionOptions EditorConstructionOptions(MonacoEditor editor)
    {
        return StandardOptions();
    }

    private StandaloneEditorConstructionOptions ViewerConstructionOptions(MonacoEditor editor)
    {
        var opts = StandardOptions();
        opts.ReadOnly = true;
        opts.Language = "css";
        return opts;
    }

    private async Task<bool> ModelChanged()
    {
        var htmlParser = new HtmlParser();
        var htmlContent = await HtmlEditor.GetValue();
        var htmlDocument = await htmlParser.ParseDocumentAsync(htmlContent);
        List<string> allClasses = new();
        foreach (var element in htmlDocument.All.Where(x => x.ClassName != null))
        {
            var classes = element.ClassName!.Split(' ', StringSplitOptions.TrimEntries | StringSplitOptions.RemoveEmptyEntries);
            allClasses.AddRange(classes);
        }

        Console.WriteLine("Gonna set the CSS value");
        await CssEditor.SetValue(_frameworkWithNoReset.Process(allClasses));

        var full = _framework.Process(allClasses);

        var previewData = new PreviewData()
        {
            Html = htmlContent,
            Css = full
        };

        Console.WriteLine("gonna send a message");
        await JS.InvokeVoidAsync("postPreviewMessage", PreviewViewer, previewData);

        return true;
    }

    private async Task EditorOnInit(MonacoEditorBase editor)
    {
        await MonacoEditorBase.DefineTheme("my-custom-theme", new StandaloneThemeData
        {
            Base = "vs-dark",
            Inherit = true,
            Rules = new List<TokenThemeRule>
            {
                new() { Background = "363636", Foreground = "E0E0E0" },
            },
            Colors = new Dictionary<string, string>
            {
                ["editor.background"] = "#FFFFFF00",
                ["editorCursor.foreground"] = "#E0E0E0",
                ["editorLineNumber.foreground"] = "#7A7A7A66"
            },
        });

        await MonacoEditor.SetTheme("my-custom-theme");
    }

    class PreviewData
    {
        public string Css { get; init; } = string.Empty;
        public string Html { get; init; } = string.Empty;
    }

    const string PreviewHtml = @"
<!-- adapted from https://github.com/tailwindlabs/play.tailwindcss.com/blob/master/src/components/Preview.js -->
<!DOCTYPE html>
<html>
<head>
    <meta charset=""utf-8"">
    <meta name=""viewport"" content=""width=device-width, initial-scale=1"">
    <style id=""_style""></style>
    <script>
        console.log('here we go')
        var hasHtml = false
        var hasCss = false
        var visible = false
        window.addEventListener('message', (e) => {
            console.log(e)
            if (typeof e.data.clear !== 'undefined') {
                setHtml()
                setCss()
                checkVisibility()
                return
            }
            if (typeof e.data.css !== 'undefined') {
                setCss(e.data.css)
            }
            if (typeof e.data.html !== 'undefined') {
                setHtml(e.data.html)
            }
            checkVisibility()
        })
        function checkVisibility() {
            if (!visible && hasHtml && hasCss) {
                visible = true
                document.body.style.display = ''
            } else if (visible && (!hasHtml || !hasCss)) {
                visible = false
                document.body.style.display = 'none'
            }
        }
        function setHtml(html) {
            if (typeof html === 'undefined') {
                document.body.innerHTML = ''
                hasHtml = false
            } else {
                document.body.innerHTML = html
                hasHtml = true
            }
        }
        function setCss(css) {
            const style = document.getElementById('_style')
            const newStyle = document.createElement('style')
            newStyle.id = '_style'
            newStyle.innerHTML = typeof css === 'undefined' ? '' : css
            style.parentNode.replaceChild(newStyle, style)
            hasCss = typeof css === 'undefined' ? false : true
        }
    </script>
</head>
<body style=""display:none"">
</body>
<script>
    // https://github.com/sveltejs/svelte-repl/blob/master/src/Output/srcdoc/index.html
    // https://github.com/sveltejs/svelte-repl/blob/master/LICENSE
    document.body.addEventListener('click', event => {
        if (event.which !== 1) return;
        if (event.metaKey || event.ctrlKey || event.shiftKey) return;
        if (event.defaultPrevented) return;

        // ensure target is a link
        let el = event.target;
        while (el && el.nodeName !== 'A') el = el.parentNode;
        if (!el || el.nodeName !== 'A') return;

        if (el.hasAttribute('download') || el.getAttribute('rel') === 'external' || el.target) return;

        event.preventDefault();
        window.open(el.href, '_blank');
    });
</script>
</html>
              
";
}

